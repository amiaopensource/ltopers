# this is a collection of shared functions for scripts in the ltopers collection

_get_iso8601(){
    date +%FT%T
}

_get_iso8601_c(){
    date +%Y%m%d-%H%M%S
}

_report(){
    local RED="$(tput setaf 1)"   # Red      - For Warnings
    local GREEN="$(tput setaf 2)" # Green    - For Declarations
    local BLUE="$(tput setaf 4)"  # Blue     - For Questions
    local NC="$(tput sgr0)"       # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ENDMESSAGE=""
    local ECHOOPT=""
    local LOG_MESSAGE=""
    OPTIND=1
    while getopts ":qdwstn" OPT; do
        case "${OPT}" in
            q) COLOR="${BLUE}" ;;                         # question mode, use color blue
            d) COLOR="${GREEN}" ;;                        # declaration mode, use color green
            w) COLOR="${RED}" ; LOG_MESSAGE="Y" ;;        # warning mode, use color red
            s) STARTMESSAGE+=([$(basename "${0}")] ) ;;   # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601) '- ' ) ;;   # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                            # to avoid line breaks after echo
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    MESSAGE="${1}"
    echo "${ECHOOPT}" "${COLOR}${STARTMESSAGE[@]}${MESSAGE}${NC}"
}

_maketemp(){
    mktemp -q "/tmp/$(basename "${0}").XXXXXX"
    if [ "${?}" -ne 0 ] ; then
        _report -w "${0}: Can't create temp file. Exiting."
        exit 1
    fi
}

_check_for_lto_index_dir(){
    if [ -z "${LTO_INDEX_DIR}" ] ; then
        LTO_INDEX_DIR="${HOME}/Documents/lto_indexes"
    fi
}

_checkdir(){
    if [[ ! -d "${1}" ]] ; then
        echo "${1}" is not a directory.
        _usage
        exit 1
    fi
}

_mkdir2(){
    local DIR2MAKE=""
    while [ "${*}" != "" ] ; do
        DIR2MAKE="${1}"
        if [ ! -d "${DIR2MAKE}" ] ; then
            mkdir -p "${DIR2MAKE}"
            if [ "${?}" -ne 0 ]; then
                _report -wt "${0}: Can't create directory at ${DIR2MAKE}"
                exit 1
            fi
        fi
        shift
    done
}

_check_for_colons(){
    COLONALERT=$(find "${1}" -iname '*:*')
    if [ -n "${COLONALERT}" ] ; then
        _report -w "Illegal characters (colons) have been detected in the following file(s):"
        for i in ${COLONALERT} ; do
            _report -w "    ${i}"
        done
        _report -w "Exiting"
        exit 1
    fi
}
