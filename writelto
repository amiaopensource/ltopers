#!/usr/bin/env bash

# writelto
# This script writes the contents of a specified directory onto a mounted
# LTFS-formated LTO tape.

SCRIPTDIR=$(dirname "${0}")
DEPENDENCIES=(rsync gcp)
TAPE_MOUNT_POINT="/Volumes"
TAPE_SERIAL_REGEX="^[A-Z0-9]{6}$"
unset HIDDEN_FILES
TAPE_EJECT="Y"
_check_for_lto_index_dir
LTO_LOGS="${LTO_INDEX_DIR}"

# no .DS_Store onto external storage
if [[ "$(uname -s)" = "Darwin" ]] ; then
    if [[ "$(defaults read com.apple.desktopservices DSDontWriteNetworkStores 2>/dev/null)" != "true" ]] ; then
        defaults write com.apple.desktopservices DSDontWriteNetworkStores true
    fi
fi

_check_dependencies(){
    DEPS_OK=YES
    while [ "${*}" != "" ] ; do
        DEPENDENCY="${1}"
        if [ ! "$(which "${DEPENDENCY}")" ] ; then
            _report -wt "This script requires ${DEPENDENCY} to run but it is not installed"
            _report -wt "If you are running ubuntu or debian you might be able to install ${DEPENDENCY} with the following command"
            _report -wt "sudo apt-get install ${DEPENDENCY}"
            _report -wt "If you are running mac you might be able to install ${DEPENDENCY} with the following command"
            _report -wt "brew install ${DEPENDENCY}"
            DEPS_OK=NO
        fi
        shift
    done
    if [[ "${DEPS_OK}" = "NO" ]]; then
        _report -wt "Unmet dependencies"
        _report -wt "Aborting!"
        exit 1
    else
        return 0
    fi
}

_check_dir(){
    if [[ ! -d "${1}" ]] ; then
        _report -w "[${1}] is not a directory."
        _usage
        exit 1
    fi
}

_check_for_colons(){
    COLONALERT=$(find "${1}" -iname '*:*')
    if [ -n "${COLONALERT}" ] ; then
        _report -w "Note that LTFS formatted tapes called store files with colons in their filenames. Colons have been detected in the following file(s):"
        for i in ${COLONALERT} ; do
            _report -w "    ${i}"
        done
        _report -w "Exiting"
        exit 1
    fi
}

_check_for_lto_md5_flags(){
    if [ -z "${LTO_MD5_FLAGS}" ] ; then
        LTO_MD5_FLAGS="md5deep -rel"
    fi
}

_check_for_lto_index_dir(){
    # if LTO_INDEX_DIR is set in ltopers.conf then that will be used, otherwise a default
    if [ -z "${LTO_INDEX_DIR}" ] ; then
        LTO_INDEX_DIR="${DEFAULT_LTO_INDEX_DIR}"
    fi
}

_get_iso8601_c(){
    date +%Y%m%d-%H%M%S
}

_mkdir2(){
    local DIR2MAKE=""
    while [ "${*}" != "" ] ; do
        DIR2MAKE="${1}"
        if [ ! -d "${DIR2MAKE}" ] ; then
            mkdir -p "${DIR2MAKE}"
            if [ "${?}" -ne 0 ]; then
                _report -wt "${0}: Can't create directory at ${DIR2MAKE}"
                exit 1
            fi
        fi
        shift
    done
}

_report(){
    local RED="$(tput setaf 1)"   # Red      - For Warnings
    local GREEN="$(tput setaf 2)" # Green    - For Declarations
    local BLUE="$(tput setaf 4)"  # Blue     - For Questions
    local NC="$(tput sgr0)"       # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ECHOOPT=""
    local LOG_MESSAGE=""
    OPTIND=1
    while getopts ":qdwstn" OPT; do
        case "${OPT}" in
            q) COLOR="${BLUE}" ;;                         # question mode, use color blue
            d) COLOR="${GREEN}" ;;                        # declaration mode, use color green
            w) COLOR="${RED}" ;;                          # warning mode, use color red
            s) STARTMESSAGE+=([$(basename "${0}")] ) ;;   # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601_c) '- ' ) ;;   # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                            # to avoid line breaks after echo
        esac
    done
    shift $(( OPTIND - 1 ))
    MESSAGE="${1}"
    echo "${ECHOOPT}" "${COLOR}${STARTMESSAGE[*]}${MESSAGE}${NC}"
}

_usage(){
    cat <<EOF
$(basename "${0}")
This script writes the contents of a specified directory onto a mounted
LTFS-formated LTO tape.
Dependencies: ${DEPENDENCIES[@]}

Usage: $(basename "${0}") -t [-e] [-v] | -h
  -t <tape_serial>    tape serial
  -e [Y|N]            state yes (Y) or no (N) to ejecting the tape after write, default
                      is yes
  -v                  reads back and creates checksums for the contents of a tape, and
                      writes checksums to a file named with the tape name and date,
                      located in the LTO logs directory
  -x                  use barcode label as tape serial (caveat: this is not standard)
  -h                  display this help
EOF
}

OPTIND=1
while getopts ":t:e:vxh" opt ; do
    case "${opt}" in
        t) TAPE_SERIAL="${OPTARG}" ;;
        e) TAPE_EJECT="${OPTARG}" ;;
        v) VERIFY="Y" ;;
        x) TAPE_SERIAL_REGEX="^[A-Z0-9]{6}(L[5-8]|M8)$" ;;
        h) _usage ; exit 0 ;;
        :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
        *) echo "Bad option -${OPTARG}" ; _usage ; exit 1 ;;
    esac
done
shift "$((OPTIND-1))"

SOURCE_DIR="${1}"

if [[ ! "${TAPE_SERIAL}" ]] ; then
    _report -qn "Enter the LTO tape barcode: "
    read -e TAPE_SERIAL
fi

if [[ ! "${SOURCE_DIR}" ]] ; then
    _report -qn "Drag in the directory to write to tape: "
    read -e SOURCE_DIR
fi

if [[ ! $(echo "${TAPE_SERIAL}" | grep -E "${TAPE_SERIAL_REGEX}") ]] ; then
    _report -w "Tape serial ${TAPE_SERIAL} is not valid."
    _report -w "Proceeding with non-standard Tape Serial"
fi
# Check for colons in filenames of source directory.
_check_for_colons "${SOURCE_DIR}"

TAPE_PATH="${TAPE_MOUNT_POINT}/${TAPE_SERIAL}"

_checkdir "${SOURCE_DIR}"
# remove .DS_Store files
find "${SOURCE_DIR}/" -name '.DS_Store' -type f -delete
if [ -f "${SOURCE_DIR}"/tapechecksum.md5 ] ; then
    db_fixity=$(cat "${SOURCE_DIR}"/tapechecksum.md5)
fi

_checkdir "${TAPE_PATH}"

gcp --preserve=mode,timestamps -nRv "${SOURCE_DIR}/"* "${TAPE_PATH}"

"${SCRIPTDIR}/migratefiles" -o "${TAPE_PATH}" "${SOURCE_DIR}/"
RSYNC_ERR_1="$?"
HIDDEN_FILES=$(find "${TAPE_PATH}" -name ".*")
if [[ "${HIDDEN_FILES}" ]] ; then
    echo "Removing hidden files from tape."
    find "${TAPE_PATH}" -name ".*" -delete
    "${SCRIPTDIR}/migratefiles" -o "${TAPE_PATH}" "${SOURCE_DIR}/"
    RSYNC_ERR_2="$?"
fi

WRITELTODIR="${LTO_LOGS}/writelto"
_mkdir2 "${WRITELTODIR}"

if [ -n "$RSYNC_ERR_2" ] ; then
    echo "rsync exited with ${RSYNC_ERR_1} on the first pass and ${RSYNC_ERR_2} on the second pass." | tee -a "${WRITELTODIR}/${TAPE_SERIAL}_writelto.txt" 2>&1
else
    echo "rsync exited with ${RSYNC_ERR_1}." | tee -a "${WRITELTODIR}/${TAPE_SERIAL}_writelto.txt" 2>&1
fi

if [[ "${PREMIS_DB}" = "Y" ]] ; then
    _report_to_db
fi

_check_for_lto_md5_flags
if [[ "${VERIFY}" = "Y" ]] ; then
    VERIFYTIME=$(_get_iso8601_c)
    READBACKDIR="${LTO_LOGS}/readback_checksums"
    _mkdir2 "${READBACKDIR}"
    find "${TAPE_PATH}" -type f ! -name .DS_Store -exec $LTO_MD5_FLAGS "{}" >> "${READBACKDIR}/${TAPE_SERIAL}_ReadBack_checksum_${VERIFYTIME}.md5" \;
fi

READBACKOUTPUT="${READBACKDIR}/${TAPE_SERIAL}_ReadBack_checksum_${VERIFYTIME}.md5"
sort -k 2 -o "${READBACKOUTPUT}" "${READBACKOUTPUT}"

echo -n "$(date +%FT%T) " >> "${LTO_LOGS}/tape_capacity.txt"
echo $(df -Ph "${TAPE_PATH}" | tail -n 1) >> "${LTO_LOGS}/tape_capacity.txt"

renameschemas -u
SCHEMA_FILE="${LTO_LOGS}/schema/${TAPE_SERIAL}.schema"

printf "\nrsync error report written to:\n\t%s/%s_writelto.txt" "${WRITELTODIR}" "${TAPE_SERIAL}"
printf "\nreadback checksums written to:\n\t%s" "${READBACKOUTPUT}"
printf "\nafter ejecting tape, lto schema file written to:\n\t%s\n\n" "${SCHEMA_FILE}"

case "${TAPE_EJECT}" in
    y|Y) umount "${TAPE_PATH}" ;;
    *)   echo "Done writing but not ejecting ${TAPE_SERIAL}." ;;
esac
